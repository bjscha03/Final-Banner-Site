  const handleFile = async (file: File) => {
    const error = validateFile(file);
    if (error) {
      setUploadError(error);
      return;
    }

    setUploadError('');
    setIsUploading(true);

    const isPdf = file.type === 'application/pdf';
    let previewUrl = '';
    let artworkWidth = 0;
    let artworkHeight = 0;

    try {
      if (isPdf) {
        // Handle PDF files
        setIsRenderingPdf(true);
        
        const pdfResult = await loadPdfToBitmap(file, {
          bannerWidthInches: widthIn,
          bannerHeightInches: heightIn,
          targetDPI: 200,
          maxDimension: 8000
        });
        
        previewUrl = pdfResult.blobUrl;
        artworkWidth = pdfResult.width;
        artworkHeight = pdfResult.height;
        
        setIsRenderingPdf(false);
      } else {
        // Handle regular image files
        previewUrl = URL.createObjectURL(file);
      }

      // Upload actual file content to server
      const form = new FormData();
      form.append("file", file);
      const response = await fetch("/.netlify/functions/upload-file", {
        method: "POST",
        body: form
      });

      if (!response.ok) {
        throw new Error(`Upload failed: ${response.statusText}`);
      }

      const result = await response.json();

      set({
        file: {
          name: file.name,
          type: file.type,
          size: file.size,
          url: previewUrl,
          isPdf,
          fileKey: result.fileKey,
          artworkWidth: artworkWidth || undefined,
          artworkHeight: artworkHeight || undefined
        },
        // Reset scale to 100% when uploading a new file
        previewScalePct: 100
      });
      
      setIsUploading(false);
    } catch (uploadError) {
      console.error('File upload error:', uploadError);
      setIsUploading(false);
      setIsRenderingPdf(false);
      toast({
        title: "Upload Error",
        description: isPdf ? "Failed to process PDF file. Please try again." : "Failed to upload file. Please try again.",
        variant: "destructive",
      });
    }
  };
