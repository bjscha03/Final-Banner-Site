import React, { useRef, useEffect, useState } from 'react';
import { Stage, Layer, Rect, Line, Text as KonvaText, Circle, RegularPolygon, Arrow, Transformer } from 'react-konva';
import { Card } from '@/components/ui/card';
import { useQuoteStore } from '@/store/quote';
import { useEditorStore } from '@/store/editor';
import { grommetPoints } from '@/lib/preview/grommets';
import Konva from 'konva';

interface EditorCanvasProps {
  selectedObjectId: string | null;
  onSelectObject: (id: string | null) => void;
}

const PIXELS_PER_INCH = 96;

const EditorCanvas: React.FC<EditorCanvasProps> = ({ selectedObjectId, onSelectObject }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const stageRef = useRef<Konva.Stage>(null);
  const transformerRef = useRef<Konva.Transformer>(null);
  
  const { widthIn, heightIn, grommets } = useQuoteStore();
  const {
    objects,
    selectedIds,
    showBleed,
    showSafeZone,
    showGrommets,
    showGrid,
    gridSize,
    selectObject,
    clearSelection,
    updateObject,
    deleteSelected,
    duplicateSelected,
    undo,
    redo,
    canUndo,
    canRedo,
    moveSelected,
    getBleedSize,
    getSafeZoneMargin,
  } = useEditorStore();
  
  const [stageSize, setStageSize] = useState({ width: 800, height: 600 });
  const [scale, setScale] = useState(1);
  const [stagePos, setStagePos] = useState({ x: 0, y: 0 });
  
  const bleedSize = getBleedSize();
  const safeZoneMargin = getSafeZoneMargin();
  
  const canvasWidthPx = widthIn * PIXELS_PER_INCH;
  const canvasHeightPx = heightIn * PIXELS_PER_INCH;
  
  // Calculate scale to fit canvas in container
  useEffect(() => {
    const updateSize = () => {
      if (!containerRef.current) return;
      
      const container = containerRef.current;
      const containerWidth = container.clientWidth - 64;
      const containerHeight = container.clientHeight - 64;
      
      const scaleX = containerWidth / canvasWidthPx;
      const scaleY = containerHeight / canvasHeightPx;
      const newScale = Math.min(scaleX, scaleY, 1);
      
      setScale(newScale);
      setStageSize({
        width: container.clientWidth,
        height: container.clientHeight,
      });
      
      setStagePos({
        x: (container.clientWidth - canvasWidthPx * newScale) / 2,
        y: (container.clientHeight - canvasHeightPx * newScale) / 2,
      });
    };
    
    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, [canvasWidthPx, canvasHeightPx]);
  
  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const cmdOrCtrl = isMac ? e.metaKey : e.ctrlKey;
      
      if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault();
        deleteSelected();
      }
      
      if (cmdOrCtrl && e.key === 'd') {
        e.preventDefault();
        duplicateSelected();
      }
      
      if (cmdOrCtrl && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (canUndo()) undo();
      }
      
      if (cmdOrCtrl && e.shiftKey && e.key === 'z') {
        e.preventDefault();
        if (canRedo()) redo();
      }
      
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        const step = e.shiftKey ? 10 : 1;
        const stepInches = step / PIXELS_PER_INCH;
        
        switch (e.key) {
          case 'ArrowUp':
            moveSelected(0, -stepInches);
            break;
          case 'ArrowDown':
            moveSelected(0, stepInches);
            break;
          case 'ArrowLeft':
            moveSelected(-stepInches, 0);
            break;
          case 'ArrowRight':
            moveSelected(stepInches, 0);
            break;
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [deleteSelected, duplicateSelected, undo, redo, canUndo, canRedo, moveSelected]);
  
  // Update transformer when selection changes
  useEffect(() => {
    if (!transformerRef.current || !stageRef.current) return;
    
    const transformer = transformerRef.current;
    const stage = stageRef.current;
    
    if (selectedIds.length === 0) {
      transformer.nodes([]);
    } else {
      const nodes = selectedIds
        .map(id => stage.findOne(`#${id}`))
        .filter(node => node !== null) as Konva.Node[];
      transformer.nodes(nodes);
    }
    
    transformer.getLayer()?.batchDraw();
  }, [selectedIds]);
  
  const handleStageClick = (e: Konva.KonvaEventObject<MouseEvent>) => {
    if (e.target === e.target.getStage()) {
      clearSelection();
    }
  };
  
  const handleObjectClick = (id: string, e: Konva.KonvaEventObject<MouseEvent>) => {
    e.cancelBubble = true;
    const addToSelection = e.evt.shiftKey || e.evt.metaKey || e.evt.ctrlKey;
    selectObject(id, addToSelection);
  };
  
  const handleObjectDragEnd = (id: string, e: Konva.KonvaEventObject<DragEvent>) => {
    const node = e.target;
    const newX = node.x() / PIXELS_PER_INCH;
    const newY = node.y() / PIXELS_PER_INCH;
    
    updateObject(id, { x: newX, y: newY });
  };
  
  const handleObjectTransformEnd = (id: string, e: Konva.KonvaEventObject<Event>) => {
    const node = e.target;
    const scaleX = node.scaleX();
    const scaleY = node.scaleY();
    
    node.scaleX(1);
    node.scaleY(1);
    
    updateObject(id, {
      x: node.x() / PIXELS_PER_INCH,
      y: node.y() / PIXELS_PER_INCH,
      width: (node.width() * scaleX) / PIXELS_PER_INCH,
      height: (node.height() * scaleY) / PIXELS_PER_INCH,
      rotation: node.rotation(),
    });
  };
  
  // Calculate grommet positions
  const grommetPositions = showGrommets && grommets !== 'none' 
    ? grommetPoints(widthIn, heightIn, grommets)
    : [];
  
  return (
    <Card ref={containerRef} className="w-full h-full bg-gray-100 overflow-hidden relative">
      <Stage
        ref={stageRef}
        width={stageSize.width}
        height={stageSize.height}
        onClick={handleStageClick}
        onTap={handleStageClick}
      >
        <Layer>
          {/* Background */}
          <Rect
            x={stagePos.x}
            y={stagePos.y}
            width={canvasWidthPx * scale}
            height={canvasHeightPx * scale}
            fill="white"
            shadowColor="black"
            shadowBlur={10}
            shadowOpacity={0.2}
            shadowOffset={{ x: 0, y: 2 }}
          />
          
          {/* Grid */}
          {showGrid && (
            <>
              {Array.from({ length: Math.ceil(widthIn / gridSize) + 1 }).map((_, i) => (
                <Line
                  key={`grid-v-${i}`}
                  points={[
                    stagePos.x + i * gridSize * PIXELS_PER_INCH * scale,
                    stagePos.y,
                    stagePos.x + i * gridSize * PIXELS_PER_INCH * scale,
                    stagePos.y + canvasHeightPx * scale,
                  ]}
                  stroke="#e0e0e0"
                  strokeWidth={1}
                  listening={false}
                />
              ))}
              {Array.from({ length: Math.ceil(heightIn / gridSize) + 1 }).map((_, i) => (
                <Line
                  key={`grid-h-${i}`}
                  points={[
                    stagePos.x,
                    stagePos.y + i * gridSize * PIXELS_PER_INCH * scale,
                    stagePos.x + canvasWidthPx * scale,
                    stagePos.y + i * gridSize * PIXELS_PER_INCH * scale,
                  ]}
                  stroke="#e0e0e0"
                  strokeWidth={1}
                  listening={false}
                />
              ))}
            </>
          )}
          
          {/* Bleed area */}
          {showBleed && (
            <Rect
              x={stagePos.x}
              y={stagePos.y}
              width={canvasWidthPx * scale}
              height={canvasHeightPx * scale}
              stroke="#ff0000"
              strokeWidth={2}
              dash={[5, 5]}
              listening={false}
            />
          )}
          
          {/* Safe zone */}
          {showSafeZone && (
            <Rect
              x={stagePos.x + safeZoneMargin * PIXELS_PER_INCH * scale}
              y={stagePos.y + safeZoneMargin * PIXELS_PER_INCH * scale}
              width={(widthIn - safeZoneMargin * 2) * PIXELS_PER_INCH * scale}
              height={(heightIn - safeZoneMargin * 2) * PIXELS_PER_INCH * scale}
              stroke="#0066ff"
              strokeWidth={2}
              dash={[10, 5]}
              listening={false}
            />
          )}
          
          {/* Grommets */}
          {grommetPositions.map((pos, idx) => (
            <Circle
              key={`grommet-${idx}`}
              x={stagePos.x + pos.x * PIXELS_PER_INCH * scale}
              y={stagePos.y + pos.y * PIXELS_PER_INCH * scale}
              radius={4 * scale}
              fill="#666"
              stroke="#333"
              strokeWidth={1}
              listening={false}
            />
          ))}
          
          {/* Canvas objects */}
          {objects
            .filter(obj => obj.visible)
            .sort((a, b) => a.zIndex - b.zIndex)
            .map(obj => {
              if (obj.type === 'text') {
                return (
                  <KonvaText
                    key={obj.id}
                    id={obj.id}
                    x={stagePos.x + obj.x * PIXELS_PER_INCH * scale}
                    y={stagePos.y + obj.y * PIXELS_PER_INCH * scale}
                    text={obj.content}
                    fontSize={obj.fontSize * scale}
                    fontFamily={obj.fontFamily}
                    fill={obj.color}
                    fontStyle={`${obj.fontWeight} ${obj.fontStyle}`}
                    textDecoration={obj.textDecoration}
                    align={obj.textAlign}
                    opacity={obj.opacity}
                    rotation={obj.rotation}
                    draggable={!obj.locked}
                    onClick={(e) => handleObjectClick(obj.id, e)}
                    onTap={(e) => handleObjectClick(obj.id, e)}
                    onDragEnd={(e) => handleObjectDragEnd(obj.id, e)}
                    onTransformEnd={(e) => handleObjectTransformEnd(obj.id, e)}
                  />
                );
              }
              
              if (obj.type === 'shape') {
                const shapeProps = {
                  key: obj.id,
                  id: obj.id,
                  x: stagePos.x + obj.x * PIXELS_PER_INCH * scale,
                  y: stagePos.y + obj.y * PIXELS_PER_INCH * scale,
                  width: obj.width * PIXELS_PER_INCH * scale,
                  height: obj.height * PIXELS_PER_INCH * scale,
                  fill: obj.fill,
                  stroke: obj.stroke,
                  strokeWidth: obj.strokeWidth * scale,
                  opacity: obj.opacity,
                  rotation: obj.rotation,
                  draggable: !obj.locked,
                  onClick: (e: Konva.KonvaEventObject<MouseEvent>) => handleObjectClick(obj.id, e),
                  onTap: (e: Konva.KonvaEventObject<MouseEvent>) => handleObjectClick(obj.id, e),
                  onDragEnd: (e: Konva.KonvaEventObject<DragEvent>) => handleObjectDragEnd(obj.id, e),
                  onTransformEnd: (e: Konva.KonvaEventObject<Event>) => handleObjectTransformEnd(obj.id, e),
                };
                
                if (obj.shapeType === 'rect') {
                  return <Rect {...shapeProps} cornerRadius={obj.cornerRadius ? obj.cornerRadius * scale : 0} />;
                } else if (obj.shapeType === 'circle') {
                  return <Circle {...shapeProps} radius={(obj.width * PIXELS_PER_INCH * scale) / 2} />;
                } else if (obj.shapeType === 'triangle') {
                  return <RegularPolygon {...shapeProps} sides={3} radius={(obj.width * PIXELS_PER_INCH * scale) / 2} />;
                } else if (obj.shapeType === 'arrow') {
                  return (
                    <Arrow
                      {...shapeProps}
                      points={[0, 0, obj.width * PIXELS_PER_INCH * scale, 0]}
                      pointerLength={10 * scale}
                      pointerWidth={10 * scale}
                    />
                  );
                }
              }
              
              return null;
            })}
          
          {/* Transformer */}
          <Transformer
            ref={transformerRef}
            boundBoxFunc={(oldBox, newBox) => {
              if (newBox.width < 5 || newBox.height < 5) {
                return oldBox;
              }
              return newBox;
            }}
          />
        </Layer>
      </Stage>
      
      {/* Dimension label */}
      <div className="absolute bottom-4 right-4 bg-white px-3 py-2 rounded shadow text-sm font-medium text-gray-700">
        {widthIn}" Ã— {heightIn}"
      </div>
    </Card>
  );
};

export default EditorCanvas;
